Все сервисы Хабра

Сообщество IT-специалистов Ответы на любые вопросы об IT Профессиональное развитие в IT Удаленная работа для IT-специалистов

Как стать автором

Мегапосты: Боли сисадмина От свайпа до фриланса Подарки для Хабра

Все потоки

Разработка

Научпоп

Администрирование

Дизайн

Менеджмент

Маркетинг

Войти Регистрация

neyronius [Автор публикации] 12 июля 2012 в 12:47

Применение замыканий в PHP

PHP [Вы не подписаны на этот хаб]

Введение в PHP 5.3 замыканий — одно из главных его новшеств и хотя после релиза прошло уже несколько лет, до сих пор не сложилось стандартной практики использования этой возможности языка. В этой статье я попробовал собрать все наиболее интересные возможности по применению замыканий в PHP.

Для начала рассмотрим, что же это такое — замыкание и в чем его особенности в PHP.

$g = 'test';

$c = function($a, $b) use($g){
echo $a . $b . $g;
};

$g = 'test2';

var_dump($c);

/*
object(Closure)#1 (2)
{
["static"]=> array(1) { ["g"]=> string(4) "test" }
["parameter"]=> array(2) {
["$a"] => string(10) ""
["$b"]=> string(10) ""
}
}
*/

Как видим, замыкание как и лямбда-функция представляют собой объект класса Closure, коорый хранит переданные параметры. Для того, чтобы вызывать объект как функцию, в PHP5.3 ввели магический метод __invoke.

function getClosure()
{
$g = 'test';

$c = function($a, $b) use($g){
echo $a . $b . $g;
};

$g = 'test2';

return $c;
}

$closure = getClosure();
$closure(1, 3); //13test

getClosure()->__invoke(1, 3); //13test

Используя конструкцию use мы наследуем переменную из родительской области видимости в локальную область видимости ламбда-функции.

Ситаксис прост и понятен. Не совсем понятно применение такого функционала в разработке web-приложений. Я просмотрел код нескольких совеременных фреймворков, использующих новые возможности языка и попытался собрать вместе их различные применения.

Функции обратного вызова

Самое очевидное применение анонимных функций — использование их в качестве функций обратного вызова (callbacks). В PHP имеется множество стандартных функций, принимающих на вход тип callback или его синоним callable введенный в PHP 5.4. Самые популярные из них array_filter, array_map, array_reduce. Функция array_map служит для итеративной обработки элементов массива. Callback-функция применяется к каждому элементу массива и в качестве результата выдается обработанный массив. У меня сразу возникло желание сравнить производительность обычной обработки массива в цикле с применением встроенной функции. Давайте поэкспериментируем.

$x = range(1, 100000);
$t = microtime(1);

$x2 = array_map(function($v){
return $v + 1;
}, $x);
//Time: 0.4395
//Memory: 22179776
//---------------------------------------

$x2 = array();
foreach($x as $v){
$x2[] = $v + 1;
}
//Time: 0.0764
//Memory: 22174788
//---------------------------------------

function tr($v){
return $v + 1;
}
$x2 = array();
foreach($x as $v){
$x2[] = tr($v);
}
//Time: 0.4451
//Memory: 22180604

Как видно, накладные расходы на большое количество вызовов функций дают ощутимый спад в производительности, чего и следовало ожидать. Хотя тест синтетический, задача обработки больших массивов возникает часто, и в данном случае применение функций обработки данных может стать тем местом, которе будет существенно тормозить ваше приложение. Будьте осторожны. Тем не менее в современных приложениях такой подход используется очень часто. Он позволяет делать код более лаконичным, особенно, если обработчик объявляется где-то в другом месте, а не при вызове.

По сути в данном контексте применение анонимных функций ничем не отличается от старого способа передачи строкового имени функции или callback-массива за исключением одной особенности — теперь мы можем использовать замыкания, то есть сохранять переменные из области видимости при создании функции. Рассмотрим пример обработки массива данных перед добавлением их в базу данных.

//объявляем функцию квотирования.
$quoter = function($v) use($pdo){
return $pdo->quote($v);//использовать эту функцию не рекомендуется, тем не менее :-)
}
$service->register(‘quoter’, $quoter);
…
//где-то в другом месте
//теперь у нас нет доступа к PDO
$data = array(...);//массив строк
$data = array_map($this->service->getQuoter(), $data);
//массив содержит обработанные данные.

Очень удобно применять анонимные функции и для фильтрации

$x = array_filter($data, function($v){ return $v > 0; });
//vs
$x = array();
foreach($data as $v)
{
if($v > 0){$x[] = $v}
}

События.

Замыкания идеально подходят в качестве обработчиков событий. Например

//где-то при конфигурации приложения.
$this->events->on(User::EVENT_REGISTER, function($user){
//обновить счетчик логинов для пользователя и т.д.
});

$this->events->on(User::EVENT_REGISTER’, function($user){
//выслать email для подтверждения.
});

//в обработчике формы регистрации
$this->events->trigger(User::EVENT_REGISTER, $user);

Вынос логики в обработчики событий с одной стороны делает код более чистым, с другой стороны — усложняет поиск ошибок — поведение системы иногда становится неожиданным для человека, который не знает, какие обработчики навешаны в данный момент.

Валидация

Замыкания по сути сохраняют некоторую логику в переменной, которая может быть выполнена или не выполнена в по ходу работы скрипта. Это то, что нужно для реализации валидаторов:

$notEmpty = function($v){ return strlen($v) > 0 ? true : “Значение не может быть пустым”; };
$greaterZero = function($v){ return $v > 0 ? true : “Значение должно быть больше нуля”; };

function getRangeValidator($min, $max){
return function($v) use ($min, $max){
return ($v >= $min && $v <= $max)
? true
: “Значение не попадает в промежуток”;
};
}

В последнем случае мы применяем функцию высшего порядка, которая возвращает другую функцию — валидатор с предустановленными границами значений. Применять валидаторы можно, например, так.

class UserForm extends BaseForm{

public function __constructor()
{
$this->addValidator(‘email’, Validators::$notEmpty);
$this->addValidator(‘age’, Validators::getRangeValidator(18, 55));
$this->addValidator(‘custom’, function($v){
//some logic
});
}

/**
* Находится в базовом классе.
*/
public function isValid()
{
…
$validationResult = $validator($value);
if($validationResult !== true){
$this->addValidationError($field, $validationResult);
}
…
}
}

Использование в формах классический пример. Также валидация может использоваться в сеттерах и геттерах обычных классов, моделях и т.д. Хорошим тоном, правда, считается декларативная валидация, когда правила описаны не в форме функций, а в форме правил при конфигурации, тем не менее, иногда такой подход очень кстати.

Выражения

В Symfony встречается очень интересное применение замыканий. Класс ExprBuilder опеделяет сущность, которая позволяет строить выражения вида

...
->beforeNormalization()
->ifTrue(function($v) { return is_array($v) && is_int(key($v)); })
->then(function($v) { return array_map(function($v) { return array('name' => $v); }, $v); })
->end()
...

В Symfony как я понял это внутренний класс, который используется для создания обработки вложенных конфигурационных массивов (поправьте меня, если не прав). Интересна идея реализации выражений в виде цепочек. В принципе вполне можно реализовать класс, который бы описывал выражения в таком виде:

$expr = new Expression();

$expr
->if(function(){ return $this->v == 4;})
->then(function(){$this->v = 42;})
->else(function(){})
->elseif(function(){})
->end()
->while(function(){$this->v >=42})
->do(function(){
$this->v --;
})
->end()
->apply(function(){/*Some code*/});

$expr->v = 4;
$expr->exec();
echo $expr->v;

Применение, конечно, экспериментально. По сути — это запись некоторого алгоритма. Реализация такого функционала достаточно сложна — выражение в идеальном случае должно хранить дерево операций. Инетересна концепция, может быть где-то такая конструкция будет полезна.

Роутинг

Во многих мини-фреймворках роутинг сейчас работает на анонимных функциях.

App::router(‘GET /users’, function() use($app){
$app->response->write(‘Hello, World!’);
});

Достаточно удобно и лаконично.

Кеширование

На хабре это уже обсуждалось, тем не менее.

$someHtml = $this->cashe->get(‘users.list’, function() use($app){
$users = $app->db->table(‘users)->all();
return $app->template->render(‘users.list’, $isers);
}, 1000);

Здесь метод get проверяет валидность кеша по ключу ‘users.list’ и если он не валиден, то обращается к функции за данными. Третий параметр определяет длительность хранения данных.

Инициализация по требованию

Допустим, у нас есть сервис Mailer, который мы вызываем в некоторых методах. Перед использованием он должен быть сконфигурирован. Чтобы не инициализировать его каждый раз, будем использовать ленивое создание объекта.

//Где-то в конфигурационном файле.
$service->register(‘Mailer’, function(){
return new Mailer(‘user’, ‘password’, ‘url’);
});

//Где-то в контроллере
$this->service(‘Mailer’)->mail(...);

Инициализация объекта произойдет только перед самым первым использованием.

Изменение поведения объектов

Иногда бывает полезно переопределить поведение объектов в процессе выполнения скрипта — добавить метод, переопределить старый, и т.д. Замыкание поможет нам и здесь. В PHP5.3 для этого нужно было использовать различные обходные пути.

class Base{

public function publicMethod(){echo 'public';}
private function privateMethod(){echo 'private';}
//будем перехватывать обращение к замыканию и вызывать его.
public function __call($name, $arguments) {
if($this->$name instanceof Closure){
return call_user_func_array($this->$name, array_merge(array($this), $arguments));
}
}
}

$b = new Base;

//создаем новый метод
$b->method = function($self){
echo 'I am a new dynamic method';
$self->publicMethod(); //есть доступ только к публичным свойствам и методам
};

$b->method->__invoke($b); //вызов через магический метод

$b->method(); //вызов через перехват обращения к методу

//call_user_func($b->{'method'}, $b); //так не работает

В принципе можно и переопределять старый метод, однако только в случае если он был определен подобным путем. Не совсем удобно. Поэтому в PHP 5.4 появилось возможность связать замыкание с объектом.

$closure = function(){
return $this->privateMethod();
}

$closure->bindTo($b, $b); //второй параметр определяет область видимости
$closure();

Конечно, модификации объекта не получилось, тем не менее замыкание получает доступ к приватным функциям и свойствам.

Передача как параметры по умолчанию в методы доступа к данным

Пример получения значения из массива GET. В случае его отсутствия значение будет получено путем вызова функции.

$name = Input::get('name', function() {return 'Fred';});

Функции высшего порядка

Здесь уже был пример создания валидатора. Приведу пример из фреймворка lithium

/**
* Writes the message to the configured cache adapter.
*
* @param string $type
* @param string $message
* @return closure Function returning boolean `true` on successful write, `false` otherwise.
*/
public function write($type, $message) {
$config = $this->_config + $this->_classes;

return function($self, $params) use ($config) {
$params += array('timestamp' => strtotime('now'));
$key = $config['key'];
$key = is_callable($key) ? $key($params) : String::insert($key, $params);

$cache = $config['cache'];
return $cache::write($config['config'], $key, $params['message'], $config['expiry']);
};
}

Метод возвращает замыкание, которое может быть использовано потом для записи сообщения в кеш.

Передача в шаблоны

Иногда в шаблон удобно передавать не просто данные, а, например, сконфигурированную функцию, которую можно вызвать из кода шаблона для получения каких либо значений.

//В контроллере
$layout->setLink = function($setId) use ($userLogin)
{
return '/users/' . $userLogin . '/set/' . $setId;
};

//В шаблоне
<a href=<?=$this->setLink->__invoke($id);?>>Set name</a>

В данном случае в шаблоне генерировалось несколько ссылок на сущности пользователя и в адресах этих ссылок фигурировал его логин.

Рекурсивное определение замыкания

Напоследок о том, как можно задавать рекурсивные замыкания. Для этого нужно передавать в use ссылку на замыкание, и вызывать ее в коде. Не забывайте об условии прекращения рекурсии

$factorial = function( $n ) use ( &$factorial ) {
if( $n == 1 ) return 1;
return $factorial( $n - 1 ) * $n;
};

print $factorial( 5 );

Многие из примеров выглядят натянуто. Сколько лет жили без них — и ничего. Тем не менее иногда применение замыкания достаточно естественно и для PHP. Умелое использование этой возможности позволит сделать код более читаемым и увеличить эффективность работы программиста. Просто нужно немного подстроить свое мышление под новую парадигму и все станет на свои места. А вообще рекомендую сравнить, как используются такие вещи в других языках типа Python. Надеюсь, что кто-нибудь нашел для себя здесь что-то новое. И конечно, если кто-то знает еще какие-нибудь интересные применения замыканий, то очень жду ваши комментарии. Спасибо!

Теги:

php

замыкания

Добавить метки

Укажите причину минуса, чтобы автор поработал над ошибками

Отправить анонимно

Пометьте публикацию своими метками
Метки лучше разделять запятой. Например: программирование, алгоритмы

Сохранить

Ой, у вас баннер убежал!

Ну. И что?

Реклама

+65

501

127k

51

Поделиться

Скопировать ссылку

Facebook

Twitter

ВКонтакте

[Telegram](https://t.me/share/url?url=https://habr.com/ru/post/147620/&title=Применение замыканий в PHP "Telegram")

[Pocket](https://getpocket.com/edit?url=https://habr.com/ru/post/147620/&title=Применение замыканий в PHP "Pocket")

Выберите рекомендации для отправки автору:

Указан только блог Орфографические ошибки Пунктуационные ошибки Отступы Текст-простыня Короткие предложения Смайлики Много форматирования Картинки Ссылки Оформление кода Рекламный характер

Отправить

Нарушение
Опишите суть нарушения

Отправить

neyronius neyronius

Пользователь

Платежная система

Похожие публикации

6 июня 2012 в 11:55

Наглядный пример использования замыканий в PHP

+22 10,9k 179 40 [Комментарии]

18 января 2012 в 17:06

Шаблонизация в PHP при помощи лямбда-функций и замыканий

+5 3,7k 42 19 [Комментарии]

10 сентября 2010 в 15:34

Замыкания в php

+76 43,6k 178 69 [Комментарии]

Вакансии

PHP-разработчик (Битрикс/Yii2) до 70 000 DigitalWand Можно удаленно

PHP-разработчик от 140 000 до 210 000 ЧИТАЙ-ГОРОД Москва

Backend разработчик (PHP) от 100 000 до 150 000 Modens Group Москва Можно удаленно

Middle PHP-разработчик от 100 000 до 160 000 Spectrum Екатеринбург

PHP-разработчик от 70 000 до 120 000 Директ Кредит Казань

Больше вакансий на Хабр Карьере

AdBlock похитил этот баннер, но баннеры не зубы — отрастут

Подробнее

Реклама

Комментарии 51

Rhaps107 12 июля 2012 в 13:23

+12

На PHP 5.3 обратил внимание на такую особенность: переменные, упомянутые в use(), если являлись «ссылками», то перестают ими быть.

Например

$contracts = ...;
$services = ...;

foreach ($contracts as &$contract) {

$contract['xxx'] = 'yyy'; // тут меняется $contracts
$contractServices = array_filter($services, function($v) use ($contract){
return $v['id'] == $contract['contractId'];
});

$contract['mmm'] = 'nnn'; // а здесь $contract уже живёт своей жизнью, $contracts не меняется

}

Проблему решает амперсенд — use (&$contract), но, имхо, такое поведение оказалось неочевидным.

neyronius 12 июля 2012 в 13:37

+3

Да. Поэтому и при рекурсивном определении замыкания в use передается ссылка с амперсандом, несмотря на то, что параметр и так объект и должен передаваться по ссылке. Скорее всего это потому что, use — это не передача параметров в функцию, а разрешение на доступ к переменным родительской области видимости после определения функции. Поэтому по-умолчанию происходит копирование значений, если явно не указана передача по ссылке.

Rhaps107 12 июля 2012 в 14:40

+1

Спасибо. Путает скорее название конструкции — «use», подсознательно предполагаешь, что оно будет использовать имеющиеся инстансы переменных вместо их клонирования :) Мысленно ставлю вам плюс.

ivvi 12 июля 2012 в 16:26

0

Что-то я не понял смысла в амперсанде вот тут: foreach (contracts as &contract)

sectus 12 июля 2012 в 16:30

+1

Подводный камень в foreach(items as &item)

sectus 12 июля 2012 в 16:46

0

Если я правильно понял, то это баг поправили .

vanxant 12 июля 2012 в 16:47

0

Вы просто не поняли суть замыканий. Перечисленное в use захватыется с теми значениями, которые оно было на момент вычисления выражения с замыканием.

Например для простоты, пусть у вас обычный нумерованный массив каких-то объектов (с индексами 0, 1, 2 и т.п.). На каждый объект вам нужно повесить одинаковый callback или event, но внутри этого callback-а вам нужно знать индекс обрабатываемого объекта в массиве, а взять снаружи скажем неоткуда (ну скажем этот callback вызывается из какой-то библиотеки, которая рассчитана на одиночные объекты и знать не знает про ваши массивы). Вот здесь вы используете как раз замыкания

for($i=0;$i<count($obj_array);++$i)
$obj_array[$i].onevent = function () use($i) { /*echo $i...*/}

Если бы не было замыкания, вы бы эту $i никак не вытащили.

Fortop 12 июля 2012 в 19:30

0

Передать ее параметром в само замыкание не судьба?

vanxant 12 июля 2012 в 19:48

0

Нет, если этот onevent вызывается какой-то сторонней библиотекой.

MUTOgen4eg 12 июля 2012 в 13:27

0

По-моему замыкания стоит использовать только в случае, когда очень(!) необходимо сохранить состояние и в обработчиках (не более 5 на событие). Остальное все от лукавого

Imenem 12 июля 2012 в 13:48

+6

Вот вам еще в копилку, из реального проекта, обертка для Doctrine DQL ExpressionBuilder:

Немного магии замыканий

/**
* Метод возвращает набор лямбда-функций
* для удобного доступа к выражениями Doctrine DQL.
*
* @example
*
* <code>
* $query_builder = $this->createSelect();
*
* // импортируем все лямбда-функции в текущую область видимости
* extract($this->getExpressions());
*
* $query_builder->where
* (
* // построим WHERE с помощью лямбда-функций
* $andx
* (
* $eq($alias('user'), ':user'),
* $eq($alias('type'), ':type'),
* $in($alias('status'), array(':active', ':disabled'))
* )
* );
* </code>
*
* @return array
*/
public function getExpressions()
{
if (!empty (static::$expressions))
{
return static::$expressions;
}

$expr_builder = $this->getExpressionBuilder();

// :TRICKY: Imenem 22.03.12
//
// Эта лямбда-функция создает прокси
// к методу объекта ExpressionsBuilder.
// После ее вызова с указанием имени метода
// будет создана лямбда-функция,
// которая вызывает одноименный метод ExpressionsBuilder,
// передавая ему полученные параметры.
$expr_proxy = function($method) use ($expr_builder)
{
return function() use ($method, $expr_builder)
{
return call_user_func_array(array($expr_builder, $method), func_get_args());
};
};

$alias = static::$alias;

static::$expressions = array
(
'alias' => function($field) use ($alias)
{
return $alias . '.' . $field;
},
'andx' => $expr_proxy('andx'),
'orx' => $expr_proxy('orx'),
'eq' => $expr_proxy('eq'),
'neq' => $expr_proxy('neq'),
'gte' => $expr_proxy('gte'),
'lte' => $expr_proxy('lte'),
'in' => $expr_proxy('in'),
'notIn' => $expr_proxy('notIn'),
'between' => $expr_proxy('between'),
'not' => $expr_proxy('not'),
'exists' => $expr_proxy('exists')
);

return static::$expressions;
}

Пример DQL-запроса

/**
* Метод возвращает актуальные на текущий день
* запланированные платежи по уровню баланса
*
* @param DateTime $date Метка времени запуска
* @param int $offset Индекс первого элемента, который должен попасть в выборку
* @param int $limit Максимальное кол-во элементов в выборке
*
* @return Acme\SomeBundle\Entity\ScheduleItem[] Массив запланированных задач
*/
public function findActualBalanceSchedules(DateTime $date = null, $offset = null, $limit = null)
{
extract($this->getExpressions());

$pt_repo = $this->getRepo('PaymentTask');

// получим лямбду, которая добавляет
// алиас сущности PaymentTask к имени поля
$pt_alias = $pt_repo->getExpressions()['alias'];

// создадим подзапрос, который выберет
// для каждой ScheduleItem все PaymentTask,
// которые были созданы не позднее суток назад,
// и не были до конца выполнены
$created_payment_tasks = $pt_repo
->createSelect()
->select($pt_alias('id'))
->andWhere
(
$gte($pt_alias('started'), ':started'),
$in($pt_alias('status'), PaymentTask::getActiveStatusSet())
);

return $this
->createActualSelect(ScheduleItem::TYPE_BALANCE, $offset, $limit)
->andWhere
(
// выберем все запланированные задачи по балансу,
// для которых не существует неоконченных платежных задач
$not($exists($created_payment_tasks))
)
// выберем задачи, созданные не позднее суток назад
->setParameter('started', (new DateTime)->sub(new DateInterval('P1D')))
->getQuery()
->getResult();
}

VolCh 12 июля 2012 в 14:20

+1

Как видим, замыкание как и лямбда-функция представляют собой объект класса Closure

Стоит уточнить, наверное, что лямбда-функция это частный случай замыкания.

А использование замыканий в PHP отчасти непопулярно, по-моему, из-за специфики PHP, работающего в CGI-режиме (логически). Грубо говоря нет никакой разницы писать function (request\_param, config_param) или function (request\_param) use (config_param), если config\_param вычисляется при каждом запросе так же как request_param.

Twin 12 июля 2012 в 14:36

0

Примеры кода на PHP это классно, но по-моему большинство идей использования можно почерпнуть из en.wikipedia.org/wiki/Closure_ (computer_science)

WoZ 12 июля 2012 в 14:40

+2

Я вот не вижу преимуществ использования замыканий. Почти все можно реализовать без их использования, но используя их, код становится сложнее и менее понятным, его сложнее поддерживать и развивать. В определенный момент поддержка такого кода может отнять времени больше чем было сэкономлено при написании кода с использованием замыканий.

Imenem 12 июля 2012 в 15:09

0

У замыканий есть такое преимущество, как возможность легковесного хранения состояния. Рассмотрим пример в котором имеются:

Порционный итератор (получает абстрактный загрузчик данных, передает ему границы порции и получает в ответ данные)

Репозиторий сущностей, который не хранит состояние и его метод для получения данных, который требует множество параметров, кроме возможных границ порции.

Сервис, который использует доступ к репозиторию с помощью порционного итератора, который тоже не хранит состояние

Используя замыкание мы можем создать легковесный адаптер, не внося изменений в репозиторий, итератор или сервис:

public function getActualScheduleItems(DateTime $date = null, DateTimeZone $time_zone = null)
{
$data_loader = function($offset, $limit) use ($date, $time_zone)
{
return $this->getRepo()->findActualPeriodicalSchedules($date, $time_zone, $offset, $limit);
};

return $this->createPortionIterator($data_loader);
}

WoZ 12 июля 2012 в 15:26

0

Понятное дело что удобнее, я этого не отрицал. Согласитесь, можно этот код написать и не используя замыкания. Я писал о том, что замыкания усложняют отладку и поддержку кода. А если неаккуратно ними пользоваться, то может еще и память течь.

Imenem 12 июля 2012 в 15:55

0

Тогда подкрепите свои слова примером того, как можно переписать это без замыканий, не сохраняя состояние в сервисе или репозитории (это идеологически и архитектурно неправильно). Я вот утверждаю, что некоторые куски кода короче, элегантнее и понятнее (выберите любые два :) с использованием замыканий.

WoZ 12 июля 2012 в 16:24

0

Просто взять и переписать, сохранив логику примера выше, красиво не выйдет. Весь дизайн кода будет отличаться, вот в примере предполагается сохранение состояние. Изменив дизайн, его можно сохранять в полях класса. Можно передавать постоянно аргументами, можно просто оформить в виде класса. Я не говорю что все сказанное применимо к этому примеру, замечу еще раз, если проектировать не предполагая использование замыканий, то задачу можно решить и без них. Просто иной подход будет.

Imenem 12 июля 2012 в 16:52

0

Сервисы и репозитории в принципе не могут хранить состояние, поэтому в полях класса хранить его нельзя. Оформить в виде класса то, что можно оформить в виде замыкания — громоздко и вряд-ли более понятно. Куча мелких классов-адаптеров — куча мелких файлов в ФС. Передавать аргументами — требует идентичности интерфейсов, а соответственно изменения классов или наследования.

если проектировать не предполагая использование замыканий, то задачу можно решить и без них

Да, вот только зачем отвергать решения, которые позволяют решить задачу лучше и проще? Здесь как раз замыкания вполне соответствуют KISS. В любой точке, в которой возможна передача коллбэка, можно, а зачастую и нужно, использовать замыкание, чтобы не плодить методы/наследники-адаптеры.

gen 12 июля 2012 в 15:34

+1

Стоит, наверное, уточнить, что этот пример будет работать только с версии 5.4 из-за указателя $this внутри замыкания.

Imenem 12 июля 2012 в 15:40

0

Любой, кто знает PHP сможет переписать пример так, чтобы он работал в 5.3:

public function getActualScheduleItems(DateTime $date = null, DateTimeZone $time_zone = null)
{
$repo = $this->getRepo();

$data_loader = function($offset, $limit) use ($repo, $date, $time_zone)
{
return $repo->findActualPeriodicalSchedules($date, $time_zone, $offset, $limit);
};

return $this->createPortionIterator($data_loader);
}

gen 12 июля 2012 в 15:58

0

Несомненно, я лишь хотел съэкономить немного времени тем, кто только разбирается с замыканиями и не знает про ньюанс с $this, тем более, что в статье про это ничего не сказано.

tnz 12 июля 2012 в 15:19

+1

Очень удобно передавать callback во всякие array_filter. Бывает удобно передать функцию куда-то внутрь.

Stdit 12 июля 2012 в 15:39

+2

Замыкания прекрасны, пусть и не настолько удобны и лаконичны, как в ECMAScript. Главное использовать их с умом и только тем, где это действительно удобно и нужно, а не потому что «это круто, модно, современно». А то есть риск получить неизлечимую злокачественную опухоль.

alpust 12 июля 2012 в 15:48

0

$expr
->if(function(){ return $this->v == 4;})
->then(function(){$this->v = 42;})
->else(function(){})
->elseif(function(){})
->end()
->while(function(){$this->v >=42})
->do(function(){
$this->v --;
})
->end()

ИМХО попахивает Монадами.

Epsiloncool 12 июля 2012 в 15:56

–1

Крайний с конца пример как бы намекает нам на возможность развития функционального программирования в PHP.

tnz 13 июля 2012 в 01:48

0

Вот как раз топик по теме habrahabr.ru/post/147612/

Epsiloncool 13 июля 2012 в 02:31

0

Вообще-то я про другое имел ввиду ))

taliban 12 июля 2012 в 16:41

+4

«замыкание как и лямбда-функция представляют собой объект класса Closure»

Автор, вы уж почитайте до конца что такое лямбда функция и что такое замыкание. Лямбда функция — это то что вы называете замыканием, и именно она есть обтект класса Closure, а замыкание это действие при котором этот обьект помнит что находилось вокруг него при создании (именно кусочек который прячется за оператором use).

neyronius 12 июля 2012 в 16:49

0

Спасибо за уточнение. Вы правы.

LisTik 12 июля 2012 в 16:44

0

Валидация — 1-й пример:

…

return frunction(v) use (min, $max){

…

В слове frunction — ошибка

neyronius 12 июля 2012 в 16:50

0

Спасибо, исправил

LisTik 12 июля 2012 в 17:17

0

А минус-то за что? Странно…

vanxant 12 июля 2012 в 17:02

+1

Замыкания — элегантный способ делать Dependancy Injection. См. например, прекрасный мини-фреймворк Silex .

Предположим, у вас есть некий интерфейс (скажем той же callback функции), который вы менять не хотите или не можете.

Но вам в каком-то месте потребовалось сделать функцию с этим интерфейсом, которой нужно зачем-то лезть в базу данных.

Откуда эта функция возьмет объект соединения с БД?

До PHP 5.3. практически единственным способом было объявить глобальную переменную global db, или ну или global app; db = app->db;

Но это засоряет глобальную область видимости и не очень работает, если у вас несколько соединений с дб.

С замыканиями вы просто объявляете функцию с нужным интерфейсом и передаете ей линк на db через use (db) в момент объявления.

vovs 12 июля 2012 в 17:06

–2

Простите, я вот понять не могу этих нововведений. PHP != Javascript. Он не событийный язык. Я не могу понять, зачем из танка самолет делать?

neyronius 12 июля 2012 в 17:08

+1

Лямбда функции не только в JS используются и не только для событий.

dxArtem 12 июля 2012 в 17:28

0

переменная = функция, use и т.д. есть и в С++11x

vanxant 12 июля 2012 в 20:11

0

Замыкания редко вот прям чтоб необходимы, но во многих случаях просто удобны своим простым синтаксисом.

Ну как пример — таблица футбольного чемпионата, нужно сделать сортировку, кто какое место занял по заданной турнирной таблице (там трюки при равенствен очков), при этом очень хочется использовать стандартный алгоритм uasort (ну не писать же свой пузырёк в тысячный раз, правильно).

Попробуйте сделать это с замыканиями и без — поймете разницу.

Epsiloncool 13 июля 2012 в 18:41

+1

Вы очень сильно ошибаетесь насчёт «PHP это не событийный язык». Костыли по поводу внедрения событий в PHP встречаются ещё со времён первой версии Pear'а, а сейчас это имеет массовый характер. Если во фреймворке нет поддержки событий (хуков), то он плох. Сейчас наступают времена асинхронности, а там без событий ну никак нельзя, поэтому готовьтесь. Читайте мануал по phpDaemon и привыкайте к событийности ))

vovs 13 июля 2012 в 19:09

0

Я, коллега, все прекрасно понимаю, и понимаю куда все движется. И готовлюсь — изучаю Node.js

И лично я считаю что в PHP это все и останется костылями, ибо чтобы это все _действительно_ работало, нужна другая идеология построения, как протокола, так и веб сервера, так и протокола http. И для человека, который хоть как то работал с javascript, все эти нововведения в PHP, ну ни как новыми не кажутся :-)

Epsiloncool 13 июля 2012 в 19:17

0

Ну а как же phpDaemon? Активно развивается. И хотя мне кажется, что nodejs местами попроще, в phpd есть свой скрытый смысл, преимущества над nodejs. Там кстати тоже уже есть и WS-клиенты и всякие XMPP-протоколы поддерживаются.

vovs 13 июля 2012 в 19:44

0

По мне, это костыль. Ну для того, чтобы это все действительно работало, нужно другой, абсолютно другой подход ко всей клиент-серверной структуре. Node.js — это и веб-сервер и язык программирование, все вместе. Именно это дает такую чудовищную мощность и гибкость. Linux + Apach + MySQL + PHP !== node.js. Я даже не знаю как выразиться точней, ибо я не могу языком PHP выразить то, что выражаю nodejs, и появление таких конструкций, как [] и {} в PHP 5.4, а также, замыканий, анонимных функций, глазами человека, который практикует javascript + nodejs выглядит… ну просто обескураживающей. Ну это просто мысли в слух, ни ради холивара. Мне очень нравится PHP, очень, и он действительно проще, чем javascript, и в первую очередь, на мой взгляд, благодаря синхронному выполнению и отсутствия событий, анонимных функций, замыканий и т.д.

Epsiloncool 13 июля 2012 в 19:55

+1

Вы смотрели phpd? Там нет никаких Apache, он сам себе сервер. По сути это то же самое, что и nodejs, только на php. Без linux и mysql вы не обойдётесь, они сами по себе, отдельно.

К сожалению, того PHP, которого мы знали 5 лет назад, скоро уже не будет. Всё будет асинхронно и персистентно)

kuzemchik 13 июля 2012 в 07:22

0

Наконецто можно нормально использовать array_map и прочее. Писать имена функций определенных рядом строкой, ну совсем неприятно было.

kuzemchik 13 июля 2012 в 07:55

+1

:%s/наконецто/наконец-то/g

zim32 15 июля 2012 в 23:37

0

//Time: 0.4395

//Time: 0.0764

А мне это уже не кажется хорошей идеей

kuzemchik 20 июля 2012 в 10:49

0

Не знаю что за цифры вы привели. У меня таких отличий в производительности не наблюдается.

test1.php

<?php
$array = range(0, 100000);
$result = array_map(function($element) { return $element+1; },$array);

test2.php

<?php
$array = range(0, 100000);
function test($element) { return $element+1;}
array_map('test',$array);

neyronius 20 июля 2012 в 10:52

0

Разница не между способом вызова анонимной функции, а между обработкой каждого элемента данных с помощью анонимной функции и обычной итерацией массива.

kuzemchik 20 июля 2012 в 10:59

0

Ясно, исходил из темы топика.

DjOnline 23 июля 2012 в 10:37

+1

$name = Input::get('name', function() {return 'Fred';});

Вот зачем изобретать велосипед, если и короче и понятнее можно написать

name=isset(_GET['name'])?$_GET['name'] :'Fred');

sectus 23 июля 2012 в 11:37

0

Пример может быть более сложным, например, значение по умолчанию нужно брать из базы.

$name = Input::get('name', function() use ($db){$config = $db->loadConfig(); return $config['default_name'];});

В Вашем же случае либо придётся написать дополнительное условие

$name=isset($_GET['name'])?$_GET['name'] :null);
if (is_null($name))
{
$config = $db->loadConfig();
$name = $config['default_name'];
}

, либо при каждом запросе обращаться к базе.

$config = $db->loadConfig();
$default_name = $config['default_name'];
$name=isset($_GET['name'])?$_GET['name'] :$default_name);

Только полноправные пользователи могут оставлять комментарии. Войдите , пожалуйста.

Что обсуждают

Сейчас

Вчера

Неделя

IPv6 — прекрасный мир, стоящий скорого перехода на него

12,2k 291

Самодельный автопилот на одноплатном компьютере (SBC) Tinker board и Arduino DUE

8,4k 36

Выпуск#31: ITренировка — актуальные вопросы и задачи от ведущих компаний

2,5k 21

SpaceX провела испытание прототипа Starship SN1, которое закончилось взрывом

17,7k 141

Корректирующие коды «на пальцах»

34,4k 20

Самодельная подводная лодка с надводной wi-fi антенной

22,1k 103

Домашний кинотеатр на Raspberry

23,8k 76

Когда я слышу слова «нейросеть восстановила», я лезу проверять бэкапы

20,1k 75

Самодельный автопилот на одноплатном компьютере (SBC) Tinker board и Arduino DUE

8,4k 36

Монады как паттерн переиспользования кода

3,8k 27

Полная домашняя автоматизация в новостройке

97,6k 410

FreeBSD: гораздо лучше GNU/Linux

42,1k 291

IPv6 — прекрасный мир, стоящий скорого перехода на него

12,2k 291

Как восстановить светодиодную лампу за 2 минуты при минимальных навыках работы с паяльником и знаниях об электронике

87,5k 284

Обязательно ли высшее образование в IT?

28,2k 282

Самое читаемое

Сутки

Неделя

Месяц

В «Яндекс.Такси» начали вычислять социальный рейтинг пассажиров

+18 30,2k 18 254 [Комментарии]

Самодельная подводная лодка с надводной wi-fi антенной

+78 22,1k 138 103 [Комментарии]

Домашний кинотеатр на Raspberry

+10 23,8k 196 76 [Комментарии]

Когда я слышу слова «нейросеть восстановила», я лезу проверять бэкапы

+128 20,1k 69 75 [Комментарии]

Тайна длиною в полвека: весь мир на ладони ЦРУ

+6 19,6k 70 12 [Комментарии]

Полная домашняя автоматизация в новостройке

+118 97,6k 671 410 [Комментарии]

Как восстановить светодиодную лампу за 2 минуты при минимальных навыках работы с паяльником и знаниях об электронике

+28 87,5k 153 284 [Комментарии]

Собеседование в луже крови

+178 71,7k 141 218 [Комментарии]

Загружаем и храним в Google Drive файлы любого размера бесплатно. Баг или Фича?

+132 59,4k 138 108 [Комментарии]

Google Interviewing Process for Software Developer Role in 2020

+67 57,1k 9 6 [Комментарии]

Samsung удалённо блокирует свои «серые» Smart TV в России. UPD — заявление Samsung

+150 145k 75 660 [Комментарии]

Коронавирус 2019-nCoV: смертность небольшая, большая летальность

+143 123k 99 411 [Комментарии]

Мне 14, и я совмещаю школу с работой в ИТ

+279 114k 296 319 [Комментарии]

Заметки о жизни в США

+276 101k 356 1203 [Комментарии]

Полная домашняя автоматизация в новостройке

+118 97,6k 671 410 [Комментарии]

Рекомендуем

Разместить

Интересно Как полностью автоматизировать квартиру — реальная история разработчика

Мегапост Боли сисадмина и как их лечить

Ваш аккаунт

Войти

Регистрация

Разделы

Публикации

Новости

Хабы

Компании

Пользователи

Песочница

Информация

Правила

Помощь

Документация

Соглашение

Конфиденциальность

Услуги

Реклама

Тарифы

Контент

Семинары

Мегапроекты

Если нашли опечатку в посте, выделите ее и нажмите Ctrl+Enter, чтобы сообщить автору.

© 2006 – 2020 « TM »

Настройка языка

О сайте

Служба поддержки

Мобильная версия

Настройка языка

Интерфейс

Русский

English

Язык публикаций

Русский

Английский

Сохранить настройки